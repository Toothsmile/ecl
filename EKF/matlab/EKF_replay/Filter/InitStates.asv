function [states, imu_start_index] = InitStates(param,imu_data,gps_data,mag_data,baro_data)

% constants
deg2rad = pi/180;

% initialise the state vector and quaternion
states = zeros(24,1);
quat = [1;0;0;0];

if (param.control.waitForGps == 1)
    % find IMU start index that coresponds to first valid GPS data
    %å¦‚æœéœ?¦ç­‰å¾…gpsï¼Œå…ˆåˆ¤æ–­ä¸‹æ˜¯å¦æœ‰GPSæ•°æ®
    %imu_data.time_us > gps_data.time_us(gps_data.start_index) 
    %find(arry,1,'first') æ‰¾å‡ºarryé¦–æ¬¡å‡ºç°1ä¸ªä¸ä¸?çš„æ•°
    %æ‰¾å‡ºgpsæ•°æ®å‡ºç°æ—¶å?çš„imuçš„time_us
    imu_start_index = (find(imu_data.time_us > gps_data.time_us(gps_data.start_index), 1, 'first' ) - 50);
    %å¦‚æœgpsæ•°æ®ä¸?‡´æ²¡æœ‰å‡ºç°ï¼Œå°±å°†imuèµ‹å?
    imu_start_index = max(imu_start_index,1);
else
    imu_start_index = 1;
end

% average first 100 accel readings to reduce effect of vibration
%del_velï¼šå˜åŒ–çš„é€Ÿåº¦å€?
%accel_dt:åªæœ‰1ç»´ï¼Œæˆ‘çŒœä»–æ˜¯åŠ é?åº¦çš„æ€»å?ï¼Œè¿™é‡Œæ‹¿x,y,zä¸‰ä¸ªæ–¹å‘çš„åŠ é€Ÿåº¦åˆ†é‡ä¸æ?çš„ç›¸/ï¼Œæœ‰ç‚¹å½’ä¸?Œ–çš„æ„Ÿè§?
initAccel(1) = mean(imu_data.del_vel(imu_start_index:imu_start_index+99,1))./mean(imu_data.accel_dt(imu_start_index:imu_start_index+99,1));
initAccel(2) = mean(imu_data.del_vel(imu_start_index:imu_start_index+99,2))./mean(imu_data.accel_dt(imu_start_index:imu_start_index+99,1));
initAccel(3) = mean(imu_data.del_vel(imu_start_index:imu_start_index+99,3))./mean(imu_data.accel_dt(imu_start_index:imu_start_index+99,1));

% align tilt using gravity vector (If the velocity is changing this will
% induce errors)
%åˆ©ç”¨é‡åŠ›å‘é‡å¯¹é½å€¾æ–œï¼ˆå¦‚æœé?åº¦æ”¹å˜å°†ä¼šå¯¼è‡´è¯¯å·®ï¼‰
quat = AlignTilt(quat,initAccel);%ç»™å››å…ƒæ•°èµ‹åˆå€?
states(1:4) = quat;

% add a roll, pitch, yaw mislignment å¢åŠ ä¸?¸ªrpyçš„åˆå§‹å·®å€?
quat_align_err = EulToQuat([param.control.rollAlignErr,param.control.pitchAlignErr,param.control.yawAlignErr]);%å°†æ¬§æ‹‰è§’è®¾ç½®çš„é”™ä½è¯¯å·®è½¬æ¢ä¸ºå››å…ƒæ•°çš„é”™ä½è¯¯å·®
quat = QuatMult(quat,quat_align_err);

% find magnetometer start index
mag_start_index = (find(mag_data.time_us > imu_data.time_us(imu_start_index), 1, 'first' ) - 5);
mag_start_index = max(mag_start_index,1);

% mean to reduce effect of noise in data
magBody(1,1) = mean(mag_data.field_ga(mag_start_index:mag_start_index+9,1));
magBody(2,1) = mean(mag_data.field_ga(mag_start_index:mag_start_index+9,2));
magBody(3,1) = mean(mag_data.field_ga(mag_start_index:mag_start_index+9,3));

% align heading and initialise the NED magnetic field states
quat = AlignHeading(quat,magBody,param.fusion.magDeclDeg*deg2rad);%é€šè¿‡ç£åœºä¸é‡åŠ›åŠ é€Ÿåº¦åˆå§‹åŒ–äº†quat
states(1:4) = quat;

% initialise the NED magnetic field states
Tbn = Quat2Tbn(quat);
states(17:19) = Tbn*magBody;

if (param.control.waitForGps == 1)
    % initialise velocity and position using gps
    states(5:7) = gps_data.vel_ned(gps_data.start_index,:);
    states(8:9) = gps_data.pos_ned(gps_data.start_index,1:2);%GPSçš„é«˜ç¨‹å¹¶æ²¡æœ‰ä½¿ç”¨ï¼Œä½¿ç”¨çš„æ˜¯æ°”å‹è®¡çš„é«˜åº¦è§‚æµ‹å?
    if(para.fusion.heightFuseMthod==1)
        states(10)=gps_data.pos_ned(gps_data.start_index,3);
    end
else
    % initialise to be stationary at the origin
    states(5:7) = zeros(1,3);
    states(8:9) = zeros(1,2);
end

if(para.fusion)
% find baro start index
baro_start_index = (find(baro_data.time_us > imu_data.time_us(imu_start_index), 1, 'first' ) - 10);
baro_start_index = max(baro_start_index,1);

% average baro data and initialise the vertical position
states(10) = -mean(baro_data.height(baro_start_index:baro_start_index+20));

end